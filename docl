#! /usr/bin/env lua

--- Docl - simple documentation for lua
--[[
local doc = require "doc"
local helptext = (require "help").help
return (doc.link(
  helptext
    :gsub("<", "&lt;")
    :gsub("(.-)\n", function (x) return (x == "" or x:sub(1,1) == " ")
        and x .. "\n"
         or doc.wrap(x, "h2") end)))
    :gsub("\n\n", "<p></p>")
]]--@INSERT_AS_TEXT
--
-- <h2>Note</h2>
-- docl names the documentation of files relative to the working directory.
--
-- if all files to be documented are inside a specific directory, you
-- should 'cd' (change-directory) there, before invoking 'docl'.
--
-- For example if you are at '/home/james/' and you call
--[[
$ docl my-programs/my-app/src/lua/*.lua
]]
-- then docl will name the output files 'my-programs.my-app.src.lua.*.lua.html'
-- (which is pretty dumb).
--
-- if you want them to be called only '*.lua.html' change the
-- directory before invoking docl.
--[[
$ cd /home/james/my-programs/my-app/src/lua
$ docl *.lua
]]
--
-- <h2>Examples</h2>
-- Here are some usage examples:
--
-- './docl *.lua'
--
-- document all .lua files in this directory
--
-- './docl *.lua */*.lua'
--
-- document all .lua files in this directory and all subdirectories
-- (but not recursive!)
--
-- './docl -d html-doc $$((find -name "*.lua"))'
--
-- recursively document all files ending in .lua and put output into 'html-doc/'
--

local docldir, file = arg[0]:match'(.*/)(.*)'
package.path = docldir .. "?.lua;" .. package.path

local help = (require "help").help
local doc = require "doc"
local opt = require "parseopt"

local function does_directory_exist(dir)
  local f = io.open(dir .. "/index.html", "r")
  local content = ""
  if f then
    content = f:read("*a")
    f:close()
  end

  local f = io.open(dir .. "/index.html", "w")
  if not f then
    return false

  else 
    f:write(content)
    f:close()
    return true
  end

end

local function handle_shell_options ()
  local defaults = {
    _v = opt.empty,
    _h = opt.empty,
    __dir = "doc",
    __lift = opt.empty,
    __show_source = "true",
  }

  local options = opt.parse(arg, defaults)

  if options._v then
    print("This docl version 1.2 - have fun!")
    return
  end

  if options._h then
    print("Synopsis")
    print(help)
    print()
    print("Further information available via the "
       .. "<a href=drcicero.github.io/docl/>docl documentation</a>.")
    return
  end

  opt.apply_defaults(options, defaults)

  if ({["true"]=true, ["false"]=false})[options.__show_source] then
    print("ERROR: unknown option --show-source '" .. word .. "'")
    print("  expected 'true' or 'false'")
    return
  end

  if not does_directory_exist(options.__dir) then
    print("ERROR: the directory '" .. options.__dir .. "' does not exist.")
    print("  please create it by executing 'mkdir " .. options.__dir .. "'")
    return
  end
  options.__dir = options.__dir .. "/"

  return options -- success
end



-- parse shell options and arguments
local options = handle_shell_options()

-- do your thing
if options then
  local links = {}
  local toc = {}
  local theliftfile

  for i, file in ipairs(options) do
    print("* " .. file)
    local sections = doc.parse_file(file, links, options.__show_source)
    local result = doc.gen_file(sections)

    if file == options.__lift then
      theliftfile = {sections=sections, result=result}

    elseif result ~= false then
      local path = file:gsub("/", ".")
      local f = io.open(options.__dir .. path .. ".html", "w")
      f:write(result)
      f:close()

      local desc = sections[1].first and sections[1].first.first or ""
      table.insert(toc, {path, desc})

    else
      print("  NO DOCS FOR " .. file)
    end
  end
  if not theliftfile then
    local sections = doc.parse_file(file, links, options.__show_source)
    local result = doc.gen_file(sections)
    theliftfile = {sections=sections, result=result}
  end


  local content, navigation = "", ""

  if theliftfile then
    for i, section in ipairs(theliftfile.sections) do
      local description = theliftfile.sections[i].first or {}
      local title = description.first

      content = content
        .. doc.wrap(title, i==1 and "h1" or "h2")
        .. "<p>"..table.concat(description, "\n"):gsub("\n\n", "</p><p>").."<p>"
        .. doc.content_template(section)

      navigation = navigation
        .. doc.wrap(title, i==1 and "h2" or "h3")
        .. doc.nav_template(section)
    end
  end

  htmltoc = doc.wrap(options.__lift and "Modules" or "Content", "h2")
    .. doc.wrap(table.concat(doc.map(toc, function (x) return
        ("<li><a class=list-link href='%s.html'><div>%s</div><div>%s</div></a></li>")
          :format(x[1], x[1], x[2])
      end), "\n  "),
      "ul style=list-style:none;padding:0", " id=content-list")

  content = content .. htmltoc
  navigation = navigation .. htmltoc

  local file = io.open(options.__dir .. "index.html", "w")
  file:write( doc.file_template(content, navigation) )

  file:close()

  local filestable = {}
  for i,e2 in ipairs(options) do
    filestable[e2:gsub("/", ".")] = true
  end
  for i,e in ipairs(links) do
    local url, hash = e.url:match'(.*)%.html#(.*)'
    if not filestable[url] then
      print("WARNING: broken link in file " .. e.file .. ":" .. e.line .. " to " .. url .. "#" .. hash)
    end
  end
end

